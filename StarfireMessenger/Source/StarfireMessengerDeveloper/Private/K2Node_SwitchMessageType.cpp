
#include "K2Node_SwitchMessageType.h"

#include "SGraphNode_K2MessageTypeSwitch.h"
#include "K2Node_MessengerNodeBase.h"

#include "Kismet/MessageTypeStatics.h"
#include "Messenger/MessageTypes.h"

#include "StarfireK2Utilities.h"
#include "Lambdas/InvokedScope.h"

// Blueprint Graph
#include "K2Node_CallFunction.h"
#include "K2Node_MakeArray.h"
#include "K2Node_SwitchInteger.h"
#include "K2Node_SetFieldsInStruct.h"

// Kismet Compiler
#include "KismetCompiler.h"

// Unreal Ed
#include "EditorCategoryUtils.h"

// Engine
#include "Kismet/BlueprintInstancedStructLibrary.h"

// Core UObject
#include "StructUtils/InstancedStruct.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(K2Node_SwitchMessageType)

#define LOCTEXT_NAMESPACE "K2Node_SwitchMessageType"

const FName UK2Node_SwitchMessageType::DefaultExecPinName( "OnDefault" );
const FName UK2Node_SwitchMessageType::DefaultDataPinName( "Default" );
const FName UK2Node_SwitchMessageType::InputPinName( "Message" );

void UK2Node_SwitchMessageType::AllocateDefaultPins( )
{
	Super::AllocateDefaultPins( );

	const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );

	CreatePin( EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute );

	const auto InputPin = CreatePin( EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FInstancedStruct>::Get(), InputPinName );
	InputPin->PinFriendlyName = LOCTEXT( "InputPin_FriendlyName", "Instanced Message" );
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType( InputPin );

	// Add default pins
	if (bHasDefaultPin)
	{
		CreatePin( EGPD_Output, UEdGraphSchema_K2::PC_Exec, DefaultExecPinName );

		const auto DefaultDataPin = CreatePin( EGPD_Output, UEdGraphSchema_K2::PC_Struct, FSf_MessageBase::StaticStruct( ), DefaultDataPinName );
		DefaultDataPin->PinFriendlyName = LOCTEXT( "MessageDataPin_FriendlyName", "Message" );
	}

	for (int32 Index = 0; Index < PinTypes.Num(); ++Index)
		CreateTypePins( PinTypes[ Index ], Index );
}

void UK2Node_SwitchMessageType::CreateTypePins( const FStarfireMessageType &Type, int Index )
{
	const FString NameBase = Type.IsValid( ) ? Type.MessageType->GetName( ) : FString::Printf( TEXT("Invalid_Case_%d"), Index );

	const FName ExecPinName( "On_" + NameBase );
	const auto ExecPin = CreatePin( EGPD_Output, UEdGraphSchema_K2::PC_Exec, ExecPinName );
	ExecPin->bNotConnectable = !Type.IsValid( );

	const auto PinObject = INVOKED_SCOPE -> const UScriptStruct*
	{
		if (Type.IsValid( ))
			return Type.MessageType.Get( );

		if (Type.CustomBaseType != nullptr)
			return Type.CustomBaseType.Get( );

		return FSf_MessageBase::StaticStruct( );
	};

	const FName DataPinName( NameBase );
	const auto DataPin = CreatePin( EGPD_Output, UEdGraphSchema_K2::PC_Struct, const_cast< UScriptStruct* >( PinObject ), DataPinName );
	DataPin->bNotConnectable = !Type.IsValid( );
	DataPin->PinFriendlyName = FText::Format( LOCTEXT( "MessageDataPin_FriendlyName", "As {0}" ), FText::FromString( NameBase ) );
}

void UK2Node_SwitchMessageType::ExpandNode( FKismetCompilerContext &CompilerContext, UEdGraph *SourceGraph )
{
	Super::ExpandNode( CompilerContext, SourceGraph );

	if (CheckForErrors( CompilerContext ))
	{
		// remove all the links to this node as they are no longer needed
		BreakAllNodeLinks( );
		return;
	}

	const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );

	///////////////////////////////////////////////////////////////////////////////////
	// Cache our guaranteed pins
	const auto Switch_Exec = GetExecPin( );
	const auto Switch_Input = GetInputPin( );
	const auto Switch_DefaultExec = GetDefaultExecPin( );
	const auto Switch_DefaultData = GetDefaultDataPin( );

	///////////////////////////////////////////////////////////////////////////////////
	// Span the function that will determine the best matching tag
	static const auto Determine_FunctionName = GET_FUNCTION_NAME_CHECKED( UMessageTypeStatics, DetermineBestMatch );
	static const FName CheckInstance_ParamName( "CheckInstance" );
	static const FName Types_ParamName( "Types" );
	
	const auto CallDetermine = CompilerContext.SpawnIntermediateNode< UK2Node_CallFunction >( this, SourceGraph );
	CallDetermine->FunctionReference.SetExternalMember( Determine_FunctionName, UMessageTypeStatics::StaticClass() );
	CallDetermine->AllocateDefaultPins( );

	const auto Determine_Exec = CallDetermine->GetExecPin( );
	const auto Determine_CheckInstance = CallDetermine->FindPinChecked( CheckInstance_ParamName );
	const auto Determine_Types = CallDetermine->FindPinChecked( Types_ParamName );

	const auto Determine_Then = CallDetermine->GetThenPin( );
	const auto Determine_Result = CallDetermine->GetReturnValuePin( );

	CompilerContext.MovePinLinksToIntermediate( *Switch_Exec, *Determine_Exec );
	CompilerContext.CopyPinLinksToIntermediate( *Switch_Input, *Determine_CheckInstance );
	CallDetermine->NotifyPinConnectionListChanged( Determine_CheckInstance );

	///////////////////////////////////////////////////////////////////////////////////
	// Make the Array of input gameplay tags
	const auto MakeArray = CompilerContext.SpawnIntermediateNode< UK2Node_MakeArray >( this, SourceGraph );
	MakeArray->NumInputs = PinTypes.Num( );
	MakeArray->AllocateDefaultPins( );

	const auto OutputPin = MakeArray->GetOutputPin( );

	K2Schema->TryCreateConnection( OutputPin, Determine_Types );

	for (int idx = 0; idx < PinTypes.Num( ); ++idx)
	{
		const auto PinName = MakeArray->GetPinName( idx );
		const auto Pin = MakeArray->FindPinChecked( PinName );

		Pin->DefaultObject = const_cast< UScriptStruct* >( PinTypes[ idx ].MessageType.Get( ) );
	}

	///////////////////////////////////////////////////////////////////////////////////
	//
	static const FName Selection_PinName( "Selection" ); // nothing is exposed for accessing this pin, dumb
	
	const auto IntSwitch = CompilerContext.SpawnIntermediateNode< UK2Node_SwitchInteger >( this, SourceGraph );
	IntSwitch->StartIndex = 0;
	IntSwitch->bHasDefaultPin = bHasDefaultPin;
	IntSwitch->AllocateDefaultPins( );

	const auto IntSwitch_Exec = IntSwitch->GetExecPin( );
	const auto IntSwitch_Input = IntSwitch->FindPinChecked( Selection_PinName );

	IntSwitch_Exec->MakeLinkTo( Determine_Then );
	IntSwitch_Input->MakeLinkTo( Determine_Result );

	///////////////////////////////////////////////////////////////////////////////////
	//
	static const auto GetInstanced_FunctionName = GET_FUNCTION_NAME_CHECKED( UBlueprintInstancedStructLibrary, GetInstancedStructValue );
	static const FName Input_ParamName( "InstancedStruct" );
	static const FName Output_ParamName( "Value" );
	static const FName Valid_ExecName( "Valid" );

	///////////////////////////////////////////////////////////////////////////////////
	// Add pins for each tag case and spawn intermediate nodes for each case
	int Index = 0;
	for (const auto &Type : PinTypes)
	{
		const auto [ TypeExecPin, TypeDataPin ] = GetTypePins( Type );

		IntSwitch->AddPinToSwitchNode( );
		const auto PinName = IntSwitch->GetPinNameGivenIndex( Index++ );
		const auto SwitchPin = IntSwitch->FindPinChecked( PinName );

		///////////////////////////////////////////////////////////////////////////////////
		//
		const auto CallGetInstanced = CompilerContext.SpawnIntermediateNode< UK2Node_CallFunction >( this, SourceGraph );
		CallGetInstanced->FunctionReference.SetExternalMember( GetInstanced_FunctionName, UBlueprintInstancedStructLibrary::StaticClass() );
		CallGetInstanced->AllocateDefaultPins( );
		
		const auto Instanced_Exec = CallGetInstanced->GetExecPin( );
		const auto Instanced_Input = CallGetInstanced->FindPinChecked( Input_ParamName );
		const auto Instanced_Valid = CallGetInstanced->FindPinChecked( Valid_ExecName );
		const auto Instanced_Output = CallGetInstanced->FindPinChecked( Output_ParamName );

		SwitchPin->MakeLinkTo( Instanced_Exec );
		CompilerContext.CopyPinLinksToIntermediate( *Switch_Input, *Instanced_Input );

		///////////////////////////////////////////////////////////////////////////////////
		//
		const auto Passthrough = CompilerContext.SpawnIntermediateNode< UK2Node_SetFieldsInStruct >( this, SourceGraph  );
		Passthrough->StructType = const_cast< UScriptStruct* >( Type.MessageType.Get( ) );
		Passthrough->bMadeAfterOverridePinRemoval = true;
		Passthrough->AllocateDefaultPins( );

		const auto PT_Exec = Passthrough->GetExecPin( );
		const auto PT_Input = Passthrough->GetStructInput( );
		const auto PT_Then = Passthrough->GetThenPin( );
		const auto PT_Output = Passthrough->GetStructOutput( );

		Instanced_Valid->MakeLinkTo( PT_Exec );
		K2Schema->TryCreateConnection( Instanced_Output, PT_Input );
		CompilerContext.MovePinLinksToIntermediate( *TypeExecPin, *PT_Then );
		CompilerContext.MovePinLinksToIntermediate( *TypeDataPin, *PT_Output );
	}

	// Move the Default pin if that's a thing that we're supporting
	if (Switch_DefaultExec != nullptr)
	{
		const auto IntSwitch_Default = IntSwitch->GetDefaultPin( );

		///////////////////////////////////////////////////////////////////////////////////
		//
		const auto CallGetInstanced = CompilerContext.SpawnIntermediateNode< UK2Node_CallFunction >( this, SourceGraph );
		CallGetInstanced->FunctionReference.SetExternalMember( GetInstanced_FunctionName, UBlueprintInstancedStructLibrary::StaticClass() );
		CallGetInstanced->AllocateDefaultPins( );
		
		const auto Instanced_Exec = CallGetInstanced->GetExecPin( );
		const auto Instanced_Input = CallGetInstanced->FindPinChecked( Input_ParamName );
		const auto Instanced_Valid = CallGetInstanced->FindPinChecked( Valid_ExecName );
		const auto Instanced_Output = CallGetInstanced->FindPinChecked( Output_ParamName );

		IntSwitch_Default->MakeLinkTo( Instanced_Exec );
		CompilerContext.CopyPinLinksToIntermediate( *Switch_Input, *Instanced_Input );

		///////////////////////////////////////////////////////////////////////////////////
		//
		const auto Passthrough = CompilerContext.SpawnIntermediateNode< UK2Node_SetFieldsInStruct >( this, SourceGraph  );
		Passthrough->StructType = FSf_MessageBase::StaticStruct( );
		Passthrough->bMadeAfterOverridePinRemoval = true;
		Passthrough->AllocateDefaultPins( );

		const auto PT_Exec = Passthrough->GetExecPin( );
		const auto PT_Input = Passthrough->GetStructInput( );
		const auto PT_Then = Passthrough->GetThenPin( );
		const auto PT_Output = Passthrough->GetStructOutput( );

		Instanced_Valid->MakeLinkTo( PT_Exec );
		K2Schema->TryCreateConnection( Instanced_Output, PT_Input );
		CompilerContext.MovePinLinksToIntermediate( *Switch_DefaultExec, *PT_Then );
		CompilerContext.MovePinLinksToIntermediate( *Switch_DefaultData, *PT_Output );
	}

	///////////////////////////////////////////////////////////////////////////////////
	//
	BreakAllNodeLinks( );
}

bool UK2Node_SwitchMessageType::CheckForErrors( const FKismetCompilerContext &CompilerContext ) const
{
	bool bErrors = false;

	const auto InputPin = GetInputPin( );
	if ((InputPin != nullptr) && InputPin->LinkedTo.IsEmpty( ))
	{
		CompilerContext.MessageLog.Error( *LOCTEXT( "MissingInput_Error", "Switch on Message Type node @@ has no input specified" ).ToString( ), this );
		bErrors = true;
	}

	if (PinTypes.IsEmpty( ))
	{
		CompilerContext.MessageLog.Error( *LOCTEXT( "MissingTypes_Error", "Switch on Message Type node @@ does not specify any cases" ).ToString( ), this );
		bErrors = true;
	}
	else
	{
		auto DupeTypes = PinTypes;
		
		if (DupeTypes.Remove( { nullptr } ) > 0)
		{
			CompilerContext.MessageLog.Error( *LOCTEXT( "NullTypes_Error", "Switch on Message Type node @@ has invalid tag entries remaining for cases" ).ToString( ), this );
			bErrors = true;
		}

		for (const auto& Type : PinTypes)
		{
			if (DupeTypes.Remove( Type ) > 1)
			{
				CompilerContext.MessageLog.Error( *FText::Format(LOCTEXT( "DuplicateTypes_Error", "Switch on Message Type node @@ specifies the same Message type '{0}' multiple times"), FText::FromString(Type.MessageType->GetName( )) ).ToString( ), this );
				bErrors = true;
			}

			if (!Type.IsNull( ) && !Type.IsValid( ) && (Type.CustomBaseType != nullptr))
			{
				CompilerContext.MessageLog.Error( *FText::Format(LOCTEXT( "InvalidTypes_Error", "Switch on Message Type node @@ specifies message type '{0}' which will never convert from '{1}'"), FText::FromString(Type.MessageType->GetName( )), FText::FromString(Type.CustomBaseType->GetName( )) ).ToString( ), this );
				bErrors = true;
			}
		}
	}

	return bErrors;
}

void UK2Node_SwitchMessageType::AddPinToSwitchNode( )
{
	auto &Type = PinTypes.AddZeroed_GetRef( );
	Type.bAllowAbstract = true;
	Type.bAllowStateful = true;
	Type.bAllowImmediate = true;
	
	Type.CustomBaseType = UK2Node_MessengerNodeBase::GetBaseAllowedType( GetInputPin( ) );
	
	CreateTypePins( Type, PinTypes.Num( ) - 1 );
}

void UK2Node_SwitchMessageType::PostReconstructNode( )
{
	Super::PostReconstructNode( );

	const auto ConnectedType = UK2Node_MessengerNodeBase::GetBaseAllowedType( GetInputPin( ) );
	for (auto &Type : PinTypes)
		Type.CustomBaseType = ConnectedType;

	if (const auto DefaultDataPin = GetDefaultDataPin( ))
		DefaultDataPin->PinType.PinSubCategoryObject = const_cast< UScriptStruct* >( ConnectedType );
}

void UK2Node_SwitchMessageType::PinConnectionListChanged( UEdGraphPin *Pin )
{
	Super::PinConnectionListChanged( Pin );

	if (Pin->PinName == InputPinName)
	{
		const auto ConnectedType = UK2Node_MessengerNodeBase::GetBaseAllowedType( GetInputPin( ) );
		for (auto &Type : PinTypes)
			Type.CustomBaseType = ConnectedType;

		if (const auto DefaultDataPin = GetDefaultDataPin( ))
			DefaultDataPin->PinType.PinSubCategoryObject = const_cast< UScriptStruct* >( ConnectedType );
	}
}

void UK2Node_SwitchMessageType::PostEditChangeChainProperty( FPropertyChangedChainEvent &PropertyChangedEvent )
{
	Super::PostEditChangeChainProperty( PropertyChangedEvent );

	const auto ChainNode = PropertyChangedEvent.PropertyChain.GetActiveNode( );
	const auto PropertyName = ChainNode->GetValue( )->GetFName( );
	if (PropertyName == GET_MEMBER_NAME_CHECKED(UK2Node_SwitchMessageType, bHasDefaultPin))
	{
		// Signal to the reconstruction logic that the default pin value has changed
		bHasDefaultPinValueChanged = true;
		
		if (!bHasDefaultPin)
		{
			if (const auto DefaultExecPin = GetDefaultExecPin())
			{
				const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );

				K2Schema->BreakPinLinks( *DefaultExecPin, true );
				
				const auto DefaultDataPin = GetDefaultDataPin( );
				K2Schema->BreakPinLinks( *DefaultDataPin, true );
			}
		}

		ReconstructNode( );

		// Clear the default pin value change flag
		bHasDefaultPinValueChanged = false;
	}
	else if (PropertyName == GET_MEMBER_NAME_CHECKED(UK2Node_SwitchMessageType, PinTypes))
	{
		ReconstructNode( );
		GetGraph( )->NotifyNodeChanged( this );
	}

	Super::PostEditChangeProperty( PropertyChangedEvent );
}

std::tuple< UEdGraphPin*, UEdGraphPin* > UK2Node_SwitchMessageType::GetTypePins( const FStarfireMessageType &Type ) const
{
	for (int idx = Pins.Num( ) - 2; idx >= 0; idx -= 2)
	{
		const auto ExecPin = Pins[ idx ];
		const auto DataPin = Pins[ idx + 1 ];

		if (ExecPin->PinName == DefaultExecPinName)
			break;

		if (DataPin->PinType.PinSubCategoryObject == Type.MessageType)
			return { ExecPin, DataPin };
	}

	return { nullptr, nullptr };
}

UEdGraphPin* UK2Node_SwitchMessageType::GetDefaultExecPin( ) const
{
	if (bHasDefaultPin)
		return FindPinChecked( DefaultExecPinName );

	return nullptr;
}

UEdGraphPin* UK2Node_SwitchMessageType::GetDefaultDataPin( ) const
{
	if (bHasDefaultPin)
		return FindPinChecked( DefaultDataPinName );

	return nullptr;
}

UEdGraphPin * UK2Node_SwitchMessageType::GetInputPin( ) const
{
	return FindPinChecked( InputPinName );
}

FText UK2Node_SwitchMessageType::GetMenuCategory( ) const
{
	static FNodeTextCache CachedCategory;
	if (CachedCategory.IsOutOfDate(this))
	{
		// FText::Format() is slow, so we cache this to save on performance
		CachedCategory.SetCachedText( FEditorCategoryUtils::BuildCategoryString( FCommonEditorCategory::FlowControl, LOCTEXT("ActionMenuCategory", "Switch") ), this );
	}
	return CachedCategory;
}

FText UK2Node_SwitchMessageType::GetNodeTitle( ENodeTitleType::Type TitleType ) const
{
	return LOCTEXT( "Switch_Type", "Switch on Message Type" );
}

FText UK2Node_SwitchMessageType::GetTooltipText( ) const
{
	return LOCTEXT( "SwitchType_ToolTip", "Selects an output that most closely matches the input message's type" );
}

FLinearColor UK2Node_SwitchMessageType::GetNodeTitleColor( ) const
{
	return FLinearColor( 255.0f, 255.0f, 0.0f );
}

FSlateIcon UK2Node_SwitchMessageType::GetIconAndTint(FLinearColor& OutColor) const
{
	static FSlateIcon Icon( FAppStyle::GetAppStyleSetName( ), "GraphEditor.Switch_16x" );
	return Icon;
}

void UK2Node_SwitchMessageType::GetMenuActions( FBlueprintActionDatabaseRegistrar &ActionRegistrar ) const
{
	StarfireK2Utilities::DefaultGetMenuActions( this, ActionRegistrar );
}

TSharedPtr< SGraphNode > UK2Node_SwitchMessageType::CreateVisualWidget( )
{
	return SNew( SGraphNode_K2MessageTypeSwitch, this );
}

#undef LOCTEXT_NAMESPACE
