
#include "K2Node_BroadcastMessage.h"

#include "Epic/K2Node_SetFieldsInStruct_Copy.h"

#include "StarfireK2Utilities.h"

// Core UObject
#include "StructUtils/InstancedStruct.h"

// Unreal Ed
#include "Kismet2/BlueprintEditorUtils.h"

// Blueprint Graph
#include "K2Node_CallFunction.h"
#include "K2Node_MakeStruct.h"

// Kismet Compiler
#include "KismetCompiler.h"
#include "Messenger/Messenger.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(K2Node_BroadcastMessage)

#define LOCTEXT_NAMESPACE "K2Node_BroadcastMessage"

UK2Node_BroadcastMessage::UK2Node_BroadcastMessage( )
{
	bAllowImmediate = true;
	bAllowStateful = true;

	bRequiresContext = true;
}

void UK2Node_BroadcastMessage::CreatePinsForType( UScriptStruct *InType, TArray<UEdGraphPin *> *OutTypePins )
{
	Super::CreatePinsForType( InType, OutTypePins );

	// lifted from K2Node_ConstructObjectFromClass (more or less)
	if (InType != nullptr)
	{
		const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );

		FInstancedStruct StructDefault( InType );
		const auto StructMemory = StructDefault.GetMemory( );

		for (TFieldIterator< FProperty > PropertyIt( InType, EFieldIteratorFlags::IncludeSuper ); PropertyIt; ++PropertyIt)
		{
			const auto Property = *PropertyIt;

			const bool bIsDelegate = Property->IsA(FMulticastDelegateProperty::StaticClass());
			if (bIsDelegate)
				continue;

			if (FindPin( Property->GetFName() ) != nullptr)
				continue;

			const bool bIsExposedToSpawn = UEdGraphSchema_K2::IsPropertyExposedOnSpawn( Property );
			if (!bIsExposedToSpawn)
				continue;
		
			const bool bIsSettableExternally = !Property->HasAnyPropertyFlags( CPF_DisableEditOnInstance );
			if (!bIsSettableExternally)
				continue;

			if (!Property->HasAllPropertyFlags( CPF_BlueprintVisible ))
				continue;

			if (Property->HasAnyPropertyFlags( CPF_Parm ))
				continue;

			if (!FBlueprintEditorUtils::PropertyStillExists( Property ))
				continue;

			if (UEdGraphPin* Pin = CreatePin( EGPD_Input, NAME_None, Property->GetFName() ))
			{
				Pin->PinFriendlyName = Property->GetDisplayNameText( );
				
				K2Schema->ConvertPropertyToPinType( Property, /*out*/ Pin->PinType );
				if (OutTypePins != nullptr)
					OutTypePins->Add(Pin);
			
				if (Property->HasAllPropertyFlags( CPF_AdvancedDisplay ))
				{
					Pin->bAdvancedView = true;

					if (AdvancedPinDisplay == ENodeAdvancedPins::NoPins)
						AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
				}

				if (StructMemory && K2Schema->PinDefaultValueIsEditable( *Pin ))
				{
					FString DefaultValueAsString;
					const auto bDefaultValueSet = FBlueprintEditorUtils::PropertyValueToString( Property, StructMemory, DefaultValueAsString, this );
					check( bDefaultValueSet );
					K2Schema->SetPinAutogeneratedDefaultValue( Pin, DefaultValueAsString );
				}

				// Copy tooltip from the property.
				K2Schema->ConstructBasicPinTooltip( *Pin, Property->GetToolTipText( ), Pin->PinToolTip );
			}
		}
	}
}

void UK2Node_BroadcastMessage::ExpandNode( FKismetCompilerContext &CompilerContext, UEdGraph *SourceGraph )
{
	Super::ExpandNode( CompilerContext, SourceGraph );

	if (CheckForErrors( CompilerContext ))
	{
		// remove all the links to this node as they are no longer needed
		BreakAllNodeLinks( );
		return;
	}

	///////////////////////////////////////////////////////////////////////////////////
	// Cache off versions of all our important pins
	const auto BroadcastExec = GetExecPin( );
	const auto BroadcastRouter = GetMessengerPin( );
	const auto BroadcastType = GetTypePin( );
	const auto BroadcastContext = GetContextPin( );

	const auto BroadcastThen = GetThenPin( );

	///////////////////////////////////////////////////////////////////////////////////
	// Construct the message data payload
	const auto MakePayload = CompilerContext.SpawnIntermediateNode< UK2Node_MakeStruct >( this, SourceGraph );
	MakePayload->StructType = CastChecked< UScriptStruct >( BroadcastType->DefaultObject );
	MakePayload->bMadeAfterOverridePinRemoval = true;
	MakePayload->AllocateDefaultPins( );
	
	const auto Make_Result = MakePayload->FindPinChecked( MakePayload->StructType->GetFName() );

	///////////////////////////////////////////////////////////////////////////////////
	// Set the desired members of the payload
	const auto SetPayload = CompilerContext.SpawnIntermediateNode< UK2Node_SetFieldsInStruct_COPY >( this, SourceGraph );
	SetPayload->StructType = CastChecked< UScriptStruct >( BroadcastType->DefaultObject );
	SetPayload->bMadeAfterOverridePinRemoval = true;
	SetPayload->bExplicitPropertyPins = true;

	for (const auto Pin : Pins)
	{
		if (!IsMessageVarPin( Pin ))
			continue;

		FOptionalPinFromProperty &PinProperty = SetPayload->ShowPinForProperties.AddDefaulted_GetRef( );
		PinProperty.PropertyName = Pin->PinName;
		PinProperty.bShowPin = true;
	}	
	
	SetPayload->AllocateDefaultPins( );

	const auto Set_Exec = SetPayload->GetExecPin( );
	const auto Set_Input = SetPayload->GetStructInput( );
	const auto Set_Then = SetPayload->GetThenPin( );
	const auto Set_Result = SetPayload->GetStructOutput( );

	///////////////////////////////////////////////////////////////////////////////////
	// Connect up all the exposed property pins

	Set_Input->MakeLinkTo( Make_Result );
	CompilerContext.MovePinLinksToIntermediate( *BroadcastExec, *Set_Exec );

	bool bMissingPins = false;
	for (const auto Pin : Pins)
	{
		if (!IsMessageVarPin( Pin ))
			continue;

		UEdGraphPin* PayloadPin = SetPayload->FindPin( Pin->PinName );
		if (PayloadPin == nullptr)
		{
			CompilerContext.MessageLog.Error( *FText::Format( LOCTEXT( "MissingStructMember_Error", "Broadcast Message @@ internal compiler error handling message property {0}." ), FText::FromString(Pin->PinName.ToString( )) ).ToString( ), this );
			bMissingPins = true;
		}

		CompilerContext.MovePinLinksToIntermediate( *Pin, *PayloadPin );
	}

	if (bMissingPins)
	{
		BreakAllNodeLinks( );
		return;
	}

	///////////////////////////////////////////////////////////////////////////////////
	// Names needed for calling the broadcast function
	static const FName Broadcast_FunctionName = GET_FUNCTION_NAME_CHECKED( UStarfireMessenger, BroadcastMessage_K2 );
	static const FName BroadcastPayload_ParamName( "MessageData" );
	static const FName BroadcastContext_ParamName( "Context" );

	///////////////////////////////////////////////////////////////////////////////////
	// Call the Broadcast Message Node
	const auto CallBroadcast = CompilerContext.SpawnIntermediateNode< UK2Node_CallFunction >( this, SourceGraph );
	CallBroadcast->FunctionReference.SetExternalMember( Broadcast_FunctionName, UStarfireMessenger::StaticClass( ) );
	CallBroadcast->AllocateDefaultPins();

	const auto CallBroadcast_Exec = CallBroadcast->GetExecPin( );
	const auto CallBroadcast_Self = CallBroadcast->FindPinChecked( StarfireK2Utilities::Self_ParamName );
	const auto CallBroadcast_Payload = CallBroadcast->FindPinChecked( BroadcastPayload_ParamName );
	const auto CallBroadcast_Context = CallBroadcast->FindPinChecked( BroadcastContext_ParamName );

	const auto CallBroadcast_Then = CallBroadcast->GetThenPin( );

	CallBroadcast_Exec->MakeLinkTo( Set_Then );
	CompilerContext.MovePinLinksToIntermediate( *BroadcastRouter, *CallBroadcast_Self );
	CallBroadcast_Payload->MakeLinkTo( Set_Result );
	CallBroadcast->PinConnectionListChanged(CallBroadcast_Payload);
	CompilerContext.MovePinLinksToIntermediate( *BroadcastContext, *CallBroadcast_Context );

	CompilerContext.MovePinLinksToIntermediate( *BroadcastThen, *CallBroadcast_Then );

	///////////////////////////////////////////////////////////////////////////////////
	//
	BreakAllNodeLinks( );
}

bool UK2Node_BroadcastMessage::CheckForErrors( const FKismetCompilerContext &CompilerContext )
{
	bool bError = Super::CheckForErrors( CompilerContext );
	
	const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );
	for (const auto Pin : Pins)
	{
		if (!IsMessageVarPin( Pin ))
			continue;
		if (Pin->bAdvancedView)
			continue;
		if (!Pin->LinkedTo.IsEmpty( ))
			continue;
		if (K2Schema->PinDefaultValueIsEditable(*Pin))
			continue;
		
		CompilerContext.MessageLog.Error( *FText::Format( LOCTEXT( "MissingParam_Error", "Broadcast Message @@ missing required message input {0}." ), FText::FromString(Pin->PinName.ToString( )) ).ToString( ), this );
		bError = true;
	}

	return bError;
}

FText UK2Node_BroadcastMessage::GetNodeTitle( ENodeTitleType::Type TitleType ) const
{
	if ((TitleType == ENodeTitleType::ListView) || (TitleType == ENodeTitleType::MenuTitle))
		return LOCTEXT( "NodeTitle", "Broadcast Message" );

	if (const auto MessageType = GetMessageType( ))
	{
		if (CachedNodeTitle.IsOutOfDate( this ))
		{
			FFormatNamedArguments Args;
			Args.Add( TEXT( "TypeName" ), MessageType->GetDisplayNameText( ) );

			// FText::Format() is slow, so we cache this to save on performance
			CachedNodeTitle.SetCachedText( FText::Format( LOCTEXT( "NodeTitle_Format", "Broadcast Message\n{TypeName}" ), Args ), this );
		}

		return CachedNodeTitle;
	}

	return LOCTEXT( "NodeTitle_NONE", "Broadcast Message\nNONE" );
}

FText UK2Node_BroadcastMessage::GetTooltipText( ) const
{
	return LOCTEXT( "NodeToolTip", "Broadcast a message with a payload and an optional object context associated with it." );
}

void UK2Node_BroadcastMessage::GetMenuActions( FBlueprintActionDatabaseRegistrar& ActionRegistrar ) const
{
	StarfireK2Utilities::DefaultGetMenuActions( this, ActionRegistrar );
}

FSlateIcon UK2Node_BroadcastMessage::GetIconAndTint( FLinearColor& OutColor ) const
{	
	return StarfireK2Utilities::GetFunctionIconAndTint( OutColor );
}

#undef LOCTEXT_NAMESPACE