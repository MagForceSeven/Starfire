
#include "K2Nodes/K2Node_HierarchicalGameplayTagSwitch.h"

#include "Kismet/GameplayTagK2Statics.h"
#include "KismetNodes/SGraphNode_K2HierarchicalGameplayTagSwitch.h"

#include "StarfireK2Utilities.h"
#include "Lambdas/InvokedScope.h"

// Gameplay Tags
#include "GameplayTags.h"

// Blueprint Graph
#include "K2Node_CallFunction.h"
#include "K2Node_MakeArray.h"
#include "K2Node_SwitchInteger.h"

// Kismet Compiler
#include "KismetCompiler.h"

// Unreal Ed
#include "EditorCategoryUtils.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(K2Node_HierarchicalGameplayTagSwitch)

#define LOCTEXT_NAMESPACE "K2Node_HierarchicalGameplayTagSwitch"

const FName UK2Node_HierarchicalGameplayTagSwitch::DefaultPinName( "Default" );
const FName UK2Node_HierarchicalGameplayTagSwitch::InputPinName( "GameplayTag" );

void UK2Node_HierarchicalGameplayTagSwitch::AllocateDefaultPins( )
{
	Super::AllocateDefaultPins( );

	const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );

	CreatePin( EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute );
	
	const auto InputPin = CreatePin( EGPD_Input, UEdGraphSchema_K2::PC_Struct, FGameplayTag::StaticStruct( ), InputPinName );
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType( InputPin );

	// Add default pin
	if (bHasDefaultPin)
		CreatePin( EGPD_Output, UEdGraphSchema_K2::PC_Exec, DefaultPinName );

	for (int32 Index = 0; Index < PinTags.Num(); ++Index)
	{
		const FName PinName = PinTags[ Index ].IsValid( ) ? PinTags[ Index ].GetTagName( ) :
			FName( FString::Printf( TEXT("Case_%d"), Index ) );

		const auto CasePin = CreatePin( EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName );
		CasePin->bNotConnectable = !PinTags[ Index ].IsValid( );
	}
}

void UK2Node_HierarchicalGameplayTagSwitch::ExpandNode( FKismetCompilerContext &CompilerContext, UEdGraph *SourceGraph )
{
	Super::ExpandNode( CompilerContext, SourceGraph );

	if (CheckForErrors( CompilerContext ))
	{
		// remove all the links to this node as they are no longer needed
		BreakAllNodeLinks( );
		return;
	}

	const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );

	///////////////////////////////////////////////////////////////////////////////////
	// Cache our guaranteed pins
	const auto Switch_Exec = GetExecPin( );
	const auto Switch_Input = GetInputPin( );
	const auto Switch_Default = GetDefaultPin( );

	///////////////////////////////////////////////////////////////////////////////////
	// Span the function that will determine the best matching tag
	static const auto Determine_FunctionName = GET_FUNCTION_NAME_CHECKED( UGameplayTagK2Statics, DetermineBestMatch );
	static const FName CheckTag_ParamName( "CheckTag" );
	static const FName Tags_ParamName( "Tags" );
	
	const auto CallDetermine = CompilerContext.SpawnIntermediateNode< UK2Node_CallFunction >( this, SourceGraph );
	CallDetermine->FunctionReference.SetExternalMember( Determine_FunctionName, UGameplayTagK2Statics::StaticClass() );
	CallDetermine->AllocateDefaultPins( );

	const auto Determine_Exec = CallDetermine->GetExecPin( );
	const auto Determine_CheckTag = CallDetermine->FindPinChecked( CheckTag_ParamName );
	const auto Determine_Tags = CallDetermine->FindPinChecked( Tags_ParamName );

	const auto Determine_Then = CallDetermine->GetThenPin( );
	const auto Determine_Result = CallDetermine->GetReturnValuePin( );

	CompilerContext.MovePinLinksToIntermediate( *Switch_Exec, *Determine_Exec );
	CompilerContext.MovePinLinksToIntermediate( *Switch_Input, *Determine_CheckTag );

	///////////////////////////////////////////////////////////////////////////////////
	// Make the Array of input gameplay tags
	const auto MakeArray = CompilerContext.SpawnIntermediateNode< UK2Node_MakeArray >( this, SourceGraph );
	MakeArray->NumInputs = PinTags.Num( );
	MakeArray->AllocateDefaultPins( );

	const auto OutputPin = MakeArray->GetOutputPin( );

	K2Schema->TryCreateConnection( OutputPin, Determine_Tags );

	for (int idx = 0; idx < PinTags.Num( ); ++idx)
	{
		const auto PinName = MakeArray->GetPinName( idx );
		const auto Pin = MakeArray->FindPinChecked( PinName );

		Pin->DefaultValue = FString::Printf( TEXT("(TagName=\"%s\")"), *PinTags[ idx ].ToString( ) );
	}

	///////////////////////////////////////////////////////////////////////////////////
	//
	static const FName Selection_PinName( "Selection" ); // nothing is exposed for accessing this pin, dumb
	
	const auto IntSwitch = CompilerContext.SpawnIntermediateNode< UK2Node_SwitchInteger >( this, SourceGraph );
	IntSwitch->StartIndex = 0;
	IntSwitch->bHasDefaultPin = bHasDefaultPin;
	IntSwitch->AllocateDefaultPins( );

	const auto IntSwitch_Exec = IntSwitch->GetExecPin( );
	const auto IntSwitch_Input = IntSwitch->FindPinChecked( Selection_PinName );

	IntSwitch_Exec->MakeLinkTo( Determine_Then );
	IntSwitch_Input->MakeLinkTo( Determine_Result );

	// Add pins for each tag case and move the external switch execs to the spawned switch
	int Index = 0;
	for (const auto &Tag : PinTags)
	{
		const auto TagPin = FindPinChecked( Tag.GetTagName( ) );
		IntSwitch->AddPinToSwitchNode( );
		const auto PinName = IntSwitch->GetPinNameGivenIndex( Index++ );
		const auto SwitchPin = IntSwitch->FindPinChecked( PinName );

		CompilerContext.MovePinLinksToIntermediate( *TagPin, *SwitchPin );
	}

	// Move the Default pin if that's a thing that we're supporting
	if (Switch_Default != nullptr)
	{
		const auto IntSwitch_Default = IntSwitch->GetDefaultPin( );

		CompilerContext.MovePinLinksToIntermediate( *Switch_Default, *IntSwitch_Default );
	}

	///////////////////////////////////////////////////////////////////////////////////
	//
	BreakAllNodeLinks( );
}

bool UK2Node_HierarchicalGameplayTagSwitch::CheckForErrors( const FKismetCompilerContext &CompilerContext ) const
{
	bool bErrors = false;

	const auto InputPin = GetInputPin( );
	if ((InputPin != nullptr) && InputPin->LinkedTo.IsEmpty( ) && InputPin->DefaultValue.Contains( "\"\"" ))
	{
		CompilerContext.MessageLog.Error( *LOCTEXT( "MissingInput_Error", "Switch on GameplayTag node @@ has no input specified" ).ToString( ), this );
		bErrors = true;
	}

	if (PinTags.IsEmpty( ))
	{
		CompilerContext.MessageLog.Error( *LOCTEXT( "MissingTags_Error", "Switch on GameplayTag node @@ does not specify any cases" ).ToString( ), this );
		bErrors = true;
	}
	else
	{
		auto DupeTags = PinTags;
		
		if (DupeTags.Remove( FGameplayTag( ) ) > 0)
		{
			CompilerContext.MessageLog.Error( *LOCTEXT( "InvalidTags_Error", "Switch on GameplayTag node @@ has invalid tag entries remaining for cases" ).ToString( ), this );
			bErrors = true;
		}

		for (const auto Tag : PinTags)
		{
			if (DupeTags.Remove( Tag ) > 1)
			{
				CompilerContext.MessageLog.Error( *LOCTEXT( "DuplicateTags_Error", "Switch on GameplayTag node @@ specifies the same tag '%s' multiple times" ).ToString( ), this, *Tag.ToString( ) );
				bErrors = true;
			}
		}
	}

	return bErrors;
}

void UK2Node_HierarchicalGameplayTagSwitch::AddPinToSwitchNode( )
{
	const FName PinName = INVOKED_SCOPE
	{
		int32 Index = 0;
		while (true)
		{
			const FName NewPinName( FString::Printf( TEXT("Case_%d"), Index++ ) );
			if (!FindPin(NewPinName))
				return NewPinName;
		}
	};

	PinTags.Add( FGameplayTag( ) );
	
	const auto Pin = CreatePin( EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName );
	Pin->bNotConnectable = true;
}

void UK2Node_HierarchicalGameplayTagSwitch::PostEditChangeProperty( FPropertyChangedEvent &PropertyChangedEvent )
{
	const auto PropertyName = (PropertyChangedEvent.Property != nullptr) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
	if (PropertyName == GET_MEMBER_NAME_CHECKED(UK2Node_HierarchicalGameplayTagSwitch, bHasDefaultPin))
	{
		// Signal to the reconstruction logic that the default pin value has changed
		bHasDefaultPinValueChanged = true;
		
		if (!bHasDefaultPin)
		{
			if (const auto DefaultPin = GetDefaultPin())
			{
				const auto K2Schema = GetDefault< UEdGraphSchema_K2 >( );
				K2Schema->BreakPinLinks( *DefaultPin, true );
			}
		}

		ReconstructNode( );

		// Clear the default pin value change flag
		bHasDefaultPinValueChanged = false;
	}
	else if (PropertyName == GET_MEMBER_NAME_CHECKED(UK2Node_HierarchicalGameplayTagSwitch, PinTags))
	{
		ReconstructNode( );
		GetGraph( )->NotifyNodeChanged( this );
	}

	Super::PostEditChangeProperty( PropertyChangedEvent );
}

UEdGraphPin* UK2Node_HierarchicalGameplayTagSwitch::GetDefaultPin( ) const
{
	if (bHasDefaultPin)
		return FindPinChecked( DefaultPinName );

	return nullptr;
}

UEdGraphPin * UK2Node_HierarchicalGameplayTagSwitch::GetInputPin( ) const
{
	return FindPinChecked( InputPinName );
}

FText UK2Node_HierarchicalGameplayTagSwitch::GetMenuCategory( ) const
{
	static FNodeTextCache CachedCategory;
	if (CachedCategory.IsOutOfDate(this))
	{
		// FText::Format() is slow, so we cache this to save on performance
		CachedCategory.SetCachedText( FEditorCategoryUtils::BuildCategoryString( FCommonEditorCategory::FlowControl, LOCTEXT("ActionMenuCategory", "Switch") ), this );
	}
	return CachedCategory;
}

FText UK2Node_HierarchicalGameplayTagSwitch::GetNodeTitle( ENodeTitleType::Type TitleType ) const
{
	return LOCTEXT( "Switch_Tag", "Switch on Gameplay Tag (Hierarchical)" );
}

FText UK2Node_HierarchicalGameplayTagSwitch::GetTooltipText( ) const
{
	return LOCTEXT( "SwitchTag_ToolTip", "Selects an output that most closely matches the input tag" );
}

FLinearColor UK2Node_HierarchicalGameplayTagSwitch::GetNodeTitleColor( ) const
{
	return FLinearColor( 255.0f, 255.0f, 0.0f );
}

FSlateIcon UK2Node_HierarchicalGameplayTagSwitch::GetIconAndTint(FLinearColor& OutColor) const
{
	static FSlateIcon Icon( FAppStyle::GetAppStyleSetName( ), "GraphEditor.Switch_16x" );
	return Icon;
}

void UK2Node_HierarchicalGameplayTagSwitch::GetMenuActions( FBlueprintActionDatabaseRegistrar &ActionRegistrar ) const
{
	StarfireK2Utilities::DefaultGetMenuActions( this, ActionRegistrar );
}

TSharedPtr< SGraphNode > UK2Node_HierarchicalGameplayTagSwitch::CreateVisualWidget( )
{
	return SNew( SGraphNode_K2HierarchicalGameplayTagSwitch, this );
}

#undef LOCTEXT_NAMESPACE
